var SIZE = {
    // CSS map to full width height
    FULL: 'full'
}


var NotImplementedError = function(message) {
    this.name = 'NotImplemented';
    this.message = message || "The reference call is not implemented";
    this.stack = (new Error(message)).stack;
}


NotImplementedError.prototype = Object.create(Error.prototype)
NotImplementedError.prototype.constructor = NotImplementedError;
NotImplementedError.throw = function(m){
    let e = new NotImplementedError(m);
    throw e;
    return e;
}


// Converts from degrees to radians.
Math.radians = function(degrees) {
  return degrees * Math.PI / 180;
};

// Converts from radians to degrees.
Math.degrees = function(radians) {
  return radians * 180 / Math.PI;
};


var _instance = {};


class BaseClass {
    /* Base app */
    constructor(...args){
        return this.init.apply(this, arguments)
    }

    init() {
        //console.log('init called')
    }

    get _app() {
        /* Hook to the base app instance. For scene sharing*/
        return _instance
    }

    static classChain(){
        /* Returns an array of string for the
        class extend list. */
        return classChain(this, true)
    }

    classChain(){
        return classChain(this.constructor, true)
    }

    static get gardenType(){
        /* return a value for Garden.
        Used during instance checking  */
        return 'class'
    }

    get gardenType(){
        return 'instance'
    }
}



class BaseProperty extends BaseClass {
    /* Create a class loading into the base Garden or other target
    class
    Like MRO but live and import inheritence. */
    static assignmentName(item) {
        return 'properties'
    }

    static assignmentReference(klass) {
         return new klass;
    }

    get name(){
        /* Return the name of the property.
        As default this is this.key() */
        return this.key();
    }

    getterSetter(){
        /* Return true to define this property as a getter setter. Rather than
        a function, a property is applied to reference object. */
        return false;
    }

    key(){
        /* Slice the word [property] from the end of the constructor name. */
        return this.constructor.name.slice(0, -'property'.length).toLowerCase();
    }

    setup(instance, scene, key, options) {
        let [_key, v] = this.instanceMethod(instance, scene, options)
        if( this.getterSetter() ) {

            if( instance.gardenType == 'instance'
                && instance[_key] == undefined
                && (_key in instance) == false) {
                Object.defineProperty(instance, _key, {
                    get: v
                    , set: v
                })
            }

        } else {
            instance[_key] = v;
        }
    }

    liveProperty(item, objReference, options){
        /* Called by the generateOptions function on first options
        detection.
        item: Class instance being generated by the generateOptions call
        objReference: The object being created for the new BABYLON object.
        options: Object configurations for the creating item BABYLON reference */
        return this.initProperty(item, objReference, options);
    }

    instanceMethod(item, scene, options) {
        /* Set a method on the instance if one is required. */
        let toSet, key, f;
        [toSet, key] = this.setInstanceMethod();

        if(!this.isTargetClass(item)) {
            // check for class.
            return
        };

        f = (function(propInst, key){

            return function propCaller(...v){
                if(!propInst.arrayProp()){
                    v = v[0]
                };

                return propInst.propCall(this, key, v);
            };

        })(this, key);

        if(toSet) {
            return [key, f]
        }
    }

    arrayProp(){
        return false;
    }

    propCall(instance, key, v, b){
        let ins = this.isTargetClass(instance)
        let pn = ins.name;
        let fn = 'getProperty'

        if(this.arrayProp()) {
            if(v.length != 0) {
                fn = 'setProperty'
            }
        } else if(v !== undefined) {
            fn = 'setProperty'
        };

        let tn = `${pn}_${fn}`;
        if(this[tn] == undefined) {
            tn = fn;
        }

        return this[tn](instance, key, v, b);
    }

    isTargetClass(item) {
        /* Returns the first mathing class instance of*/
        for(let _type of this.instanceTypes()) {
            if(item instanceof _type) return _type;
        };
        return false;
    }

    instanceTypes() {
        return [BabylonObject]
    }

    setInstanceMethod(){
        return [true, this.key()]
    }

    initProperty(item, objReference, options) {
        /* First method called in a sequence for a loading property.
        Returned is the live instance value within the options.*/
        return [this.name, this.initValue(item, objReference, options)];
    }

    initValue(item, objReference, options){
        return options[this.name]
    }

    afterProperty(babylon, instance, key, properties){
        /* Called by assignLiveProperties immediately after the
        babylon execution. This method should assign values
        to the BABYLON instance. */
        this.propCall(instance, key, properties[key], babylon)
    }

    setProperty(instance, key, value, babylon) {
        /* Set the value to the instance, optionally recieving a babylon
        instance */
        babylon = babylon || instance._babylon;
        babylon[key] = value;
    }

    getProperty(instance, key, babylon){
        /* Get the key from the instance.
        By default this returns the value applied by `initProperty`*/
        // babylon = babylon || instance._babylon;
        babylon = babylon || instance._babylon;
        if(babylon[key] != undefined) { return babylon[key]; }
        return instance._properties[key]
    }
}



class SimpleIter {

    constructor(d){
        this._ = d || {}
    }

    add(name, func, iterExisting=false) {
        if(this._[name] == undefined) {
            this._[name] = []
        }

        this._[name].push(func);
    }

    call(...args) {
        let v;
        for(let k in this._) {
            for(let f of this._[k]) {
                v = f(...args)
                if(v === null) console.warn('iterator', k, 'for', args[0], 'returned null')
            }
        }
    }

    remove(name, func) {
        let removed = []
        if(func != undefined) {
            let n = this._[name];
            if(n != undefined) {
                let i = this._[name].indexOf(func);
                if(i>-1){
                    removed = this._[name].splice(i, 1)
                }
            }
        } else if(this._[name] != undefined){
            removed = this._[name]
            delete this._[name]
        }
        return removed;
    }
}

